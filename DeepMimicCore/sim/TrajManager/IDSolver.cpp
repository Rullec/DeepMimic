#include "IDSolver.h"
#include "BulletInverseDynamics/IDConfig.hpp"
#include "scenes/SceneImitate.h"
#include "sim/Controller/CtPDController.h"
#include "sim/SimItems/SimCharacter.h"
#include "sim/SimItems/SimCharacterGen.h"
#include "util/BulletUtil.h"
#include <BulletDynamics/Featherstone/btMultiBodyLink.h>
#include <BulletInverseDynamics/MultiBodyTree.hpp>
#include <BulletInverseDynamics/details/IDLinearMathInterface.hpp>
#include <iostream>
cIDSolver::cIDSolver(cSceneImitate *imitate_scene, eIDSolverType type)
{
    // spdlog::info("cIDSolver::cIDSolver");
    // mLogger = cLogUtil::CreateLogger("cIDSolver");

    assert(imitate_scene != nullptr);
    mScene = imitate_scene;
    // std::cout << "pose = " << mSimChar->GetPose().transpose() << std::endl;
    mSimChar = imitate_scene->GetCharacter(0).get();
    mSimCharType = mSimChar->GetCharType();
    mKinChar = imitate_scene->GetKinChar().get();
    mWorld = mSimChar->GetWorld().get();

    mWorldScale = mSimChar->GetWorld()->GetScale();
    mCharController =
        std::dynamic_pointer_cast<cCtPDController>(mSimChar->GetController())
            .get();
    mType = type;
    mFloatingBase = mSimChar->HasFloatingBase();
    MIMIC_ASSERT(mSimChar != nullptr);
    MIMIC_ASSERT(mCharController != nullptr && mCharController->IsValid());

    InitFeaVariables();
    InitGenVariables();
}

cIDSolver::~cIDSolver()
{
    // this tree is generated by bullet, but we need to free it manually here
    delete mInverseModel;
    delete[] omega_buffer;
    delete[] vel_buffer;
}

eIDSolverType cIDSolver::GetType() { return mType; }

void cIDSolver::RecordReward(double &reward) const
{
    reward = mScene->CalcReward(0);
}

void cIDSolver::RecordRefTime(double &time) const
{
    time = mKinChar->GetTime();
}

/**
 * \brief					Record current action of the
 * character
 * \param					the ref of action which will be
 * revised then
 */
void cIDSolver::RecordAction(tVectorXd &action) const
{
    assert(mCharController != nullptr);
    action = mCharController->GetCurAction();
    // std::cout << "void cIDSolver::RecordAction get action:void
    // cIDSolver::RecordAction " << action.transpose() << std::endl; exit(1);
}

/**
 * \brief                   Record current joint forces of the characterI
 */
void cIDSolver::RecordJointForces(tEigenArr<tVector> &joint_forces) const
{

    if (mSimCharType == eSimCharacterType::Featherstone)
        RecordJointForcesFea(joint_forces);
    else if (mSimCharType == eSimCharacterType::Generalized)
        RecordJointForcesGen(joint_forces);
}

/**
 * \brief					Record current pd target pose of
 * the character \param					the ref of pd target in
 * this time
 */
void cIDSolver::RecordPDTarget(tVectorXd &pd_target) const
{
    // ball joints are in quaternions in pd target
    assert(mCharController != nullptr);
    pd_target = mCharController->GetCurPDTargetPose();
}

/**
 * \brief           Clear the Inverse Dynamics info
 */
void cIDSolver::ClearID()
{
    if (mSimCharType == eSimCharacterType::Featherstone)
    {
        mInverseModel->clearAllUserForcesAndMoments();
    }
}

void cIDSolver::RecordMultibodyInfo(const cSimCharacterBase *sim_char,
                                    tEigenArr<tMatrix> &local_to_world_rot,
                                    tEigenArr<tVector> &link_pos_world,
                                    tEigenArr<tVector> &link_omega_world,
                                    tEigenArr<tVector> &link_vel_world)
{
    if (sim_char->GetCharType() == eSimCharacterType::Featherstone)
    {
        RecordMultibodyInfoFea(sim_char, local_to_world_rot, link_pos_world,
                               link_omega_world, link_vel_world);
    }
    else
    {
        RecordMultibodyInfoGen(sim_char, local_to_world_rot, link_pos_world,
                               link_omega_world, link_vel_world);
    }
}

void cIDSolver::RecordMultibodyInfo(cSimCharacterBase *sim_char,
                                    tEigenArr<tMatrix> &local_to_world_rot,
                                    tEigenArr<tVector> &link_pos_world)
{
    if (sim_char->GetCharType() == eSimCharacterType::Featherstone)
    {
        RecordMultibodyInfoFea(sim_char, local_to_world_rot, link_pos_world);
    }
    else
    {
        RecordMultibodyInfoGen(sim_char, local_to_world_rot, link_pos_world);
    }
}

/**
 * \brief               Record the current contact forces applied on the
 * character in this world
 */
void cIDSolver::RecordContactForces(
    tEigenArr<tContactForceInfo> &mContactForces, double mCurTimestep) const
{
    if (mSimCharType == eSimCharacterType::Featherstone)
    {
        RecordContactForcesFea(mContactForces, mCurTimestep);
    }
    else if (mSimCharType == eSimCharacterType::Generalized)
    {
        RecordContactForcesGen(mContactForces, mCurTimestep);
    }
}

/**
 * \brief               Solve the control torque on each joint by given current
 * motion (Inverse Dynamcis)
 */
void cIDSolver::SolveIDSingleStep(
    tEigenArr<tVector> &solved_joint_forces,
    const tEigenArr<tContactForceInfo> &contact_forces,
    const tEigenArr<tVector> &link_pos, const tEigenArr<tMatrix> &link_rot,
    const tVectorXd &mBuffer_q, const tVectorXd &mBuffer_u,
    const tVectorXd &mBuffer_u_dot, int frame_id,
    const tEigenArr<tVector> &mExternalForces,
    const tEigenArr<tVector> &mExternalTorques) const
{
    if (mSimCharType == eSimCharacterType::Featherstone)
    {
        SolveIDSingleStepFea(solved_joint_forces, contact_forces, link_pos,
                             link_rot, mBuffer_q, mBuffer_u, mBuffer_u_dot,
                             frame_id, mExternalForces, mExternalTorques);
    }
    else if (mSimCharType == eSimCharacterType::Generalized)
    {
        SolveIDSingleStepGen(solved_joint_forces, contact_forces, link_pos,
                             link_rot, mBuffer_q, mBuffer_u, mBuffer_u_dot,
                             frame_id, mExternalForces, mExternalTorques);
    }
}

/**
 * \brief               Set genrealized velocity
 *
 */
void cIDSolver::SetGeneralizedVel(const tVectorXd &qdot)
{
    if (mSimCharType == eSimCharacterType::Featherstone)
    {
        SetGeneralizedVelFea(qdot);
    }
    else if (mSimCharType == eSimCharacterType::Generalized)
    {
        SetGeneralizedVelGen(qdot);
    }
}

/**
 * \brief                Calculate the gen vel
 *      1. for featherstone backend, the gen vel is the rotate vel of each joint
 * freedom
 *      2. for gen backend, the gen vel is the time derivation of gen coordinate
 */
tVectorXd cIDSolver::CalcGeneralizedVel(const tVectorXd &q_before,
                                        const tVectorXd &q_after,
                                        double timestep) const
{
    if (mSimCharType == eSimCharacterType::Featherstone)
    {
        return CalcGeneralizedVelFea(q_before, q_after, timestep);
    }
    else if (mSimCharType == eSimCharacterType::Generalized)
    {
        return CalcGeneralizedVelGen(q_before, q_after, timestep);
    }
    else
    {
        MIMIC_ERROR("Unsupported char type {}", mSimCharType);
        return tVectorXd::Zero(0);
    }
}

/**
 * \brief                   Record the perturbs recorded in the sim world
 */
void cIDSolver::RecordExternalPerturb(tEigenArr<tVector> &mPerturbForces,
                                      tEigenArr<tVector> &mPerturbTorques) const
{
    mPerturbForces.resize(mNumLinks);
    mPerturbTorques.resize(mNumLinks);

    for (int link_id = 0; link_id < mNumLinks; link_id++)
    {
        mPerturbForces[link_id].setZero();
        mPerturbTorques[link_id].setZero();
    }

    auto manager = mWorld->GetPerturbManager();
    // std::cout << "[debug] perturb num = " << manager.GetNumPerturbs()
    //           << std::endl;
    for (int id = 0; id < manager.GetNumPerturbs(); id++)
    {
        auto p = manager.GetPerturb(id);
        if (true == p.HasExpired())
            continue;
        auto link = dynamic_cast<cSimBodyLink *>(p.mObj);
        int inverse_id = link->GetJointID() + 1;

        // if (link != nullptr)
        // {
        //     std::cout << "obj " << link->GetJointID() << " "
        //               << p.mObj->GetName() << " gets perturb "
        //               << p.mPerturb.transpose() << std::endl;
        // }
        tVector force = p.mPerturb;
        tVector local_pos = p.mLocalPos;
        // 1. calculate the equavilent torque
        tVector world_vec = link->GetWorldTransform() * local_pos;
        tVector torque = world_vec.cross3(force);

        mPerturbForces[inverse_id] += force;
        mPerturbTorques[inverse_id] += torque;
        std::cout << "[record] perturb: link " << inverse_id << " force = "
                  << mPerturbForces[inverse_id].transpose().segment(0, 3)
                  << " torque = "
                  << mPerturbTorques[inverse_id].transpose().segment(0, 3)
                  << std::endl;
    }
    // if (manager.GetNumPerturbs() != 0)
    //     exit(0);
}